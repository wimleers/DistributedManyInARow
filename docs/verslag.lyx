#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\begin_preamble
\setcounter{page}{0}
\end_preamble
\use_default_options true
\language dutch
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Project Gedistribueerde Systemen: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset

Many-In-A-Row
\end_layout

\begin_layout Author
Kristof Bamps 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset

Wim Leers 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset

Brecht Schoolmeesters
\end_layout

\begin_layout Date
Academiejaar 2009-2010
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Aanpak
\end_layout

\begin_layout Standard
We zijn begonnen met het bouwen van een standaard vier-op-een-rij implementatie.
 Vervolgens hebben we de onderliggende lagen gebouwd die nodig zijn voor
 een gedistribueerde versie van vier-op-een-rij.
 Hierbij hebben we de netwerklogica geabstraheerd, zodat het spel deze eenvoudig
 kan gebruiken door het sturen van berichten over het netwerk.
\end_layout

\begin_layout Standard
Eerst hebben we gepoogd om geen IP multicast te gebruiken, maar om alle
 communicatie via Zeroconf te laten verlopen.
 Dit bleek onmogelijk: zie sectie 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Zeroconf-vs-multicast"

\end_inset

.
 Daarom hebben we naast Zeroconf ook IP multicast gebruikt.
 We hebben het spel eerst geïmplementeerd aan de hand van het 
\emph on
global state
\emph default
 principe, maar ook dit werk was overbodig, want we moesten uiteindelijk
 
\emph on
elections
\emph default
 gebruiken.
 Zie sectie 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:GlobalState-vs-Elections"

\end_inset

.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Is dit te negatief?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Concurrent met de backend implementatie werd er ook aan de GUI gewerkt.
 Deze wordt door de backend geüpdatet door callbacks telkens er een bericht
 ontvangen wordt.
 
\end_layout

\begin_layout Standard
De laatste stap was het samenvoegen van de backend met de GUI en het uitgebreid
 testen van de applicatie.
 Dit werd gedaan door netwerkdelays te veroorzaken terwijl het spel gespeeld
 werd.
 Daarna werd dan gecontroleerd of de weergave van het spelbord consistent
 was in iedere instantie van het spel.
\end_layout

\begin_layout Section
DistributedGame
\end_layout

\begin_layout Standard
DistributedGame is een Python package dat alle logica voor een gedistribueerd
 spel abstraheert.
 Het is opgebouwd uit meerdere lagen — iedere laag heeft zijn verantwoordelijkhe
id, net zoals bij het TCP/IP model 
\begin_inset CommandInset citation
LatexCommand cite
key "TCP/IP model"

\end_inset

.
\end_layout

\begin_layout Subsection
Zeroconf networking versus IP multicast
\begin_inset CommandInset label
LatexCommand label
name "sub:Zeroconf-vs-multicast"

\end_inset


\end_layout

\begin_layout Standard
Eerst was het de bedoeling om alles d.m.v.
 zeroconf (zero configuration) networking te doen.
 Zeroconf werkt op basis van DNS en het wisselt informatie uit d.m.v.
 DNS TXT records.
 In verscheidene bronnen werd vermeld dat de maximum grootte van DNS TXT
 records 64 KB bedraagt.
 Er werd echter niet expliciet bij vermeld dat daarmee bedoeld werd dat
 de 
\emph on
som
\emph default
 van de lengtes van alle DNS TXT records van één zeroconf service 64 KB
 mocht zijn, maar dat een enkel DNS record steeds beperkt was tot 255 bytes.
\end_layout

\begin_layout Standard
We hadden het dus een mooie abstractielaag rond zeroconf gebouwd en — hoewel
 ze werkte — bleek onbruikbaar in de praktijk, tenzij er aan sterke fragmentatie
 werd gedaan.
 We hebben dus uiteindelijk geopteerd om toch IP multicast te gebruiken
 voor het zenden van berichten: daar ligt de limiet van een enkel bericht
 op 64 KB.
\end_layout

\begin_layout Standard
We hebben deze zeroconf abstractie wel nog steeds gebruikt voor automatische
 discovery van peers en het uitwisselen van informatie over de actieve spellen.
\end_layout

\begin_layout Standard
Opmerking: als we betere parate kennis van DNS hadden, hadden we dus opgemerkt
 dat 64 KB per TXT record niet kon.
 Dit omdat de limiet van een DNS pakket als geheel begrensd wordt door de
 limiet van UDP.
 DNS werkt immers bovenop UDP.
 
\begin_inset CommandInset citation
LatexCommand cite
key "DNS gebruikt UDP"

\end_inset


\end_layout

\begin_layout Subsection
Schema
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/DistributedGame.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Structuur.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
ZeroconfMessaging.py
\begin_inset CommandInset label
LatexCommand label
name "sub:ZeroconfMessaging.py"

\end_inset


\end_layout

\begin_layout Standard
Dit is de abstractie rond zeroconf networking 
\begin_inset CommandInset citation
LatexCommand cite
key "zeroconf networking"

\end_inset

 die reeds werd aangehaald in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Zeroconf-vs-multicast"

\end_inset

.
 Er zijn callbacks voor:
\end_layout

\begin_layout Itemize
de registratie van de eigen service en het deregistreren van de service
\end_layout

\begin_layout Itemize
het ontdekken, updaten (gewijzigde TXT records) en verwijderen van een peer
\end_layout

\begin_layout Standard
Berichten worden verstuurd door middel van de 
\family typewriter
inbox
\family default
 en 
\family typewriter
outbox
\family default
 queues.
 Voordat deze queues aangesproken worden, moet er uiteraard eerst een lock
\begin_inset Note Note
status open

\begin_layout Plain Layout
het kan aan mij liggen, maar je komt hier ineens uit het niets met een lock.
 mss een beetje context daarover als dat nodig is?
\end_layout

\end_inset

 aangevraagd worden.
\end_layout

\begin_layout Standard
Er wordt gebruik gemaakt van pybonjour 
\begin_inset CommandInset citation
LatexCommand cite
key "pybonjour"

\end_inset

, wat een directe wrapper rond de C API is van de Bonjour (door Apple) 
\begin_inset CommandInset citation
LatexCommand cite
key "Apple Bonjour"

\end_inset

 implementatie van zeroconf.
 Het zou ook op Linux moeten werken, meerbepaald met Avahi 
\begin_inset CommandInset citation
LatexCommand cite
key "Avahi"

\end_inset

, welke een compatibility layer heeft die de Bonjour API nabootst.
 Jammer genoeg is die compatibility layer niet 
\emph on
volledig
\emph default
, terwijl wij vrijwel de volledige API gebruiken (het crasht onder andere
 bij aanroepen naar 
\family typewriter
DNSServiceAddRecord
\family default
).
\end_layout

\begin_layout Standard
Deze ZeroconfMessaging module heeft zijn eigen thread (
\family typewriter
ZeroconfMessaging-Thread
\family default
).
 De code flow is onvermijdelijk heel erg moeilijk te volgen omdat je een
 service registreert (
\family typewriter
DNSServiceRegister
\family default
) bij de zeroconf daemon, tesamen met een callback function.
 Ook geef je een 
\emph on
service type
\emph default
 op, bijvoorbeeld 
\family typewriter
_http._tcp
\family default
.
 Tegelijkertijd wordt er gezocht naar services met hetzelfde service type,
 dit noemt men 
\emph on
browsen
\emph default
 (
\family typewriter
DNSServiceBrowse
\family default
), waarbij een callback functie moet meegegeven worden.
 Als die callback wordt aangeroepen, moet je weer een andere functie aanroepen
 om gevonden peers te 
\emph on
resolven
\emph default
 (
\family typewriter
DNSServiceResolve
\family default
) en ook die een callback function meegeven.
 Als díe callback functie wordt aangeroepen, moet je nog eens twéé andere
 functies aanroepen, en moet je opnieuw callback functies meegeven om het
 DNS A record op te vragen om het IP adres van deze peer te bemachtigen
 ( 
\family typewriter
DNSServiceQueryRecord(rrtype = kDNSServiceType_A)
\family default
) en een 
\begin_inset Quotes eld
\end_inset

long lived TXT record query
\begin_inset Quotes erd
\end_inset

 (
\family typewriter
DNSServiceQueryRecord(flags = kDNSServiceFlagsLongLivedQuery, rrtype = kDNSServi
ceType_TXT)
\family default
), waarvan de callback functie elke keer wordt aangeroepen als het TXT record
 van die peer verandert.
\end_layout

\begin_layout Standard
In deze laatste callback functie zit vervolgens de meeste logica, want die
 ontvangt enkel geüpdatete TXT records als geheel, de exacte verandering
 moet er nog uitgefilterd worden!
\end_layout

\begin_layout Standard
Voor pybonjour was er geen documentatie omdat die in principe hetzelfde
 is als die van Bonjour zelf.
 Regelmatig waren er heel erg tricky edge cases die nergens expliciet vermeld
 waren, maar na een zoektocht door de documentatie hebben we de oplossingen
 uiteindelijk wel gevonden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/zeroconf naming scheme.gif
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Zeroconf networking addressing scheme.
\begin_inset CommandInset label
LatexCommand label
name "fig:Zeroconf-networking-addressing"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
IPMulticastMessaging.py
\begin_inset CommandInset label
LatexCommand label
name "sub:IPMulticastMessaging.py"

\end_inset


\end_layout

\begin_layout Standard
Zoals de naam al doet vermoeden is dit dan de abstractie rond IP multicast
 networking 
\begin_inset CommandInset citation
LatexCommand cite
key "IP multicast"

\end_inset

 die ook reeds werd aangehaald in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Zeroconf-vs-multicast"

\end_inset

.
 Berichten worden wederom verstuurd door middel van de 
\family typewriter
inbox
\family default
 en 
\family typewriter
outbox
\family default
 queues.
 Ook voordat deze queues aangesproken worden, moet er uiteraard eerst een
 lock
\begin_inset Note Note
status open

\begin_layout Plain Layout
weer dat lock
\end_layout

\end_inset

 aangevraagd worden.
\end_layout

\begin_layout Standard
Er worden twee sockets aangemaakt: één om multicast berichten op te ontvangen
 en één met een random poort om berichten te verzenden.
 Deze laatste socket is in principe overbodig, maar zorgt ervoor dat iedere
 instantie een unieke poort gebruikt, wat nodig is indien je meerdere instanties
 van 
\family typewriter
ZeroconfMessaging
\family default
 naast elkaar wilt draaien.
 De zeroconf daemon genereert dan automatisch een nieuwe naam in het geval
 van een collision.
 Zo krijg je dan bijvoorbeeld '
\family typewriter
WimLeers.local
\family default
' en '
\family typewriter
WimLeers.local (2)
\family default
'.
\end_layout

\begin_layout Standard
Aangezien iedereen berichten kan sturen naar een multicast group, is er
 een mechanisme ingebouwd om te 
\begin_inset Quotes eld
\end_inset

subscriben
\begin_inset Quotes erd
\end_inset

 op de berichten van een bepaald IP.
 Via zeroconf vind je namelijk peers met een overeenkomstig service type
 en diens IP adressen en op die manier kan je dus enkel de UDP pakketten
 die van die IP adressen komen, doorlaten.
 Dit biedt enige weerstand tegen flooding.
 
\end_layout

\begin_layout Standard
Ook deze Python module heeft zijn eigen thread (
\family typewriter
IPMulticastMessaging-Thread
\family default
).
 Dat is nodig om packets te ontvangen, welke tevens gefragmenteerd kunnen
 zijn.
 Voor fragmentatie wordt een eenvoudig protocol gebruikt: ten eerste wordt
 er een unieke packet ID gegenereerd (een UUID), vervolgens wordt het packet
 gefragmenteerd verzonden.
 Er is een fixed header size van 46 bytes: 36 karakters voor de UUID, 5
 karakters voor het sequence number en 5 karakters die het totale aantal
 fragmenten voorstellen.
 De fragmenten worden per packet ID in een buffer bijgehouden en zodra alle
 fragmenten van een pakket ontvangen zijn, worden ze weer samengevoegd.
\end_layout

\begin_layout Subsection
Service.py
\begin_inset CommandInset label
LatexCommand label
name "sub:Service.py"

\end_inset


\end_layout

\begin_layout Standard
Deze Python module stelt een 
\begin_inset Quotes eld
\end_inset

high-level service
\begin_inset Quotes erd
\end_inset

 voor, waarmee bedoeld wordt dat als je deze module gebruikt, je geen details
 moet kennen wat betreft service discovery (waarvoor zeroconf networking
 gebruikt wordt) en multicast messaging (waarvoor IP multicast networking
 gebruikt wordt).
\end_layout

\begin_layout Subsubsection
Service
\begin_inset CommandInset label
LatexCommand label
name "sub:Service"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
Service
\family default
 is de basis klasse en intialiseert de IP multicast layer (
\family typewriter
IPMulticastMessaging
\family default
 instantie) en de zeroconf layer (
\family typewriter
ZeroconfMessaging
\family default
 instantie).
 
\family typewriter
Service
\family default
 heeft callbacks die overeenkomen met die van 
\family typewriter
ZeroconfMessaging
\family default
 (zie 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:ZeroconfMessaging.py"

\end_inset

).
 Zodra een peer ontdekt wordt, wordt automatisch 
\family typewriter
IPMulticastMessaging
\family default
's 
\family typewriter
subscribe()
\family default
 method aangeroepen met diens IP.
\end_layout

\begin_layout Standard

\family typewriter
ZeroconfMessaging
\family default
 wordt dus gebruikt om andere instanties van een service met hetzelfde type
 te ontdekken en 
\family typewriter
IPMulticastMessaging
\family default
 wordt gebruikt om effectief berichten uit te wisselen.
\end_layout

\begin_layout Subsubsection
OneToOneService
\begin_inset CommandInset label
LatexCommand label
name "sub:OneToOneService"

\end_inset


\end_layout

\begin_layout Standard
Deze subclass van 
\family typewriter
Service
\family default
 wordt niet gebruikt: hij is er enkel voor de volledigheid.
 Deze class dient gebruikt te worden indien er maar 1 bestemming is binnen
 een applicatie.
 Bijvoorbeeld 1 globale chat room i.p.v.
 meerdere chat rooms.
\end_layout

\begin_layout Subsubsection
OneToManyService
\begin_inset CommandInset label
LatexCommand label
name "sub:OneToManyService"

\end_inset


\end_layout

\begin_layout Standard
Dit is dus de tegenhanger van 
\family typewriter
OneToOneService
\family default
 en wordt wél gebruikt.
 Onze implementatie ondersteunt namelijk meerdere spellen tegelijkertijd.
\end_layout

\begin_layout Standard
Om dit mogelijk te maken, voegt deze een extra laag toe: bij het verzenden
 van berichten dien je een bestemming op te geven.
 Voor iedere bestemming wordt automatisch een aparte inbox aangemaakt.
 Dit is dus in feite een routerlaag, die ervoor zorgt dat de berichten op
 de juiste bestemming 
\emph on
binnen
\emph default
 het programma terecht komen.
\end_layout

\begin_layout Standard
Er is ook één speciale bestemming: de 
\emph on
service-to-service
\emph default
 bestemming.
 Deze is voorbehouden om pakketten op 
\begin_inset Quotes eld
\end_inset

globaal niveau
\begin_inset Quotes erd
\end_inset

 uit te wisselen (bijvoorbeeld tijdsynchronisatie) terwijl de 
\begin_inset Quotes eld
\end_inset

gewone bestemmingen
\begin_inset Quotes erd
\end_inset

 op het 
\begin_inset Quotes eld
\end_inset

lokale niveau
\begin_inset Quotes erd
\end_inset

 werken (bijvoorbeeld meerdere chat rooms).
\begin_inset Note Note
status open

\begin_layout Plain Layout
dit is niet zo duidelijk
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Omdat we bij een hogere laag zijn aangekomen, moet je niet meer rechtstreeks
 op queues werken, maar zijn er methods voorzien om dit intuïtiever te maken.
\begin_inset Note Note
status open

\begin_layout Plain Layout
welke?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Voor 
\family typewriter
OneToManyService
\family default
 zijn er unit tests voorzien: we kunnen dus zeker zijn dat de routerfunctionalit
eit correct werkt.
\end_layout

\begin_layout Subsection
MessageProcessor.py
\begin_inset CommandInset label
LatexCommand label
name "sub:MessageProcessor.py"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
MessageProcessor 
\family default
is de klasse die ervoor zorgt dat bij elke speler hetzelfde spelbord te
 zien is, met ander woorden: dat berichten in de juiste volgorde aankomen.
 Ook zorgt deze klasse ervoor dat onvoorziene 
\emph on
leaves (crashes)
\emph default
 van spelers worden opgevangen.
 
\end_layout

\begin_layout Standard

\family typewriter
MessageProcessor
\family default
 moet geïnitialiseerd worden met een 
\family typewriter
OneToManyService
\family default
 instantie, een session UUID en een sender UUID.
 De session UUID dient als destination
\begin_inset Note Note
status open

\begin_layout Plain Layout
niet zo duidelijk, kan weer aan mijn liggen :s
\end_layout

\end_inset

 (als 
\begin_inset Quotes eld
\end_inset

kanaal
\begin_inset Quotes erd
\end_inset

 eigenlijk) voor 
\family typewriter
OneToManyService
\family default
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:OneToManyService"

\end_inset

.
 In het chatroom voorbeeld zorgt dit ervoor dat alle berichten voor die
 chatroom bij alle andere deelnemers aankomen.
 De sender UUID dient om iedere deelnemer uniek te kunnen identificeren.
\end_layout

\begin_layout Standard
Om ervoor te zorgen dat elke speler hetzelfde spelbord te zien krijgt, hebben
 we gewerkt met een server die gekozen wordt door middel van elections.
 Hierbij hebben we gekozen voor het bully-algoritme.
 Een election wordt gestart als de vorige server is gecrasht, of deze het
 spel heeft verlaten.
 Bij dit algoritme is er het probleem dat bij een election meerdere clients
 zichzelf tot server kunnen uitroepen, dit hebben we opgevangen door te
 werken met NTP-timestamps.
 Door bij het starten van het spel de NTP-offset met de huidige klok op
 te vragen, is het mogelijk om nauwkeurig de NTP-tijd te berekenen.
 Als er dan meerdere clients zichzelf tot server uitroepen beslissen we,
 aan de hand van de NTP-tijd waarop ze dit deden, welke effectief de server
 zal worden.
 Dit zal degene worden die als laatste zichzelf tot server uitriep (dus
 degene met de hoogste NTP-timestamp).
\end_layout

\begin_layout Standard
Als er een bericht via de 
\family typewriter
MessageProcessor 
\family default
verstuurd werd dat als bestemming de server heeft, kan het zijn dat de server
 in de tussentijd gecrasht is.
 Om ervoor te zorgen dat deze berichten niet verloren gaan, houden we een
 lijst van deze verzonden messages bij.
 Zodra de server deze messages goedkeurt, worden ze uit de lijst verwijderd.
 Als een bericht time-out, zal het opnieuw verstuurd worden.
 Hierdoor zal een bericht uiteindelijk aankomen bij de nieuwe server.
\end_layout

\begin_layout Standard
Wanneer er in de 
\family typewriter
OneToManyService 
\family default
een bericht ontvangen werd met als bestemming onze sessionUUID, zal het
 bericht hier verwerkt of doorgegeven worden.
 Berichten die specifiek voor de server bedoeld zijn (zoals een verzoek
 om een zet te doen), zullen enkel worden verwerkt door de server.
\end_layout

\begin_layout Standard

\family typewriter
MessageProcessor 
\family default
zorgt ook voor het detecteren van gecrashte processen.
 Het doet dit door keep-alive messages naar alle andere spelers te sturen.
 Er wordt zo'n bericht gestuurd om de gemiddelde RTT (Round Trip Time) tot
 elke andere speler te berekenen.
 Hierdoor kunnen we snel detecteren of een proces gecrasht is bij een snelle
 verbinding, en flooden we trage verbindingen niet.
 Een proces detecteren we als gecrasht, als er binnen de 5 RTT's nog geen
 keep-alive message is binnengekomen.
 Om deze RTT te berekenen gebruiken we wederom NTP, we kunnen de RTT halen
 uit het verschil tussen het tijdstip van verzenden en ontvangst.
 Als er geen NTP beschikbaar is (er is geen internet beschikbaar), sturen
 we deze keep-alive messages op een vast interval, en wachten we 10 seconden
 op de aankomst van deze messages, voordat we een proces als gecrasht detecteren.
 We hebben gekozen voor zo'n grote delay om ervoor te zorgen dat clients
 die enkele seconden delay ondervinden, niet onmiddelijk beschouwd worden
 als 
\begin_inset Quotes eld
\end_inset

gecrashed
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
Player.py
\begin_inset CommandInset label
LatexCommand label
name "sub:Player.py"

\end_inset


\end_layout

\begin_layout Standard
Deze extreem eenvoudige klasse stelt een speler voor in een gedistribueerd
 spel.
 Er wordt automatisch een unieke identifier gegenereerd: een UUID.
 Aan de hand van de base 10 voorstelling van deze UUID wordt ook een unieke
 kleur gegenereerd.
\end_layout

\begin_layout Subsection
Game.py
\begin_inset CommandInset label
LatexCommand label
name "sub:Game.py"

\end_inset


\end_layout

\begin_layout Standard
Ten slotte is er nog de 
\family typewriter
Game
\family default
 klasse, die een 
\family typewriter
OneToManyService
\family default
 en een 
\family typewriter
Player
\family default
 verwacht als parameters.
 Vervolgens genereert deze een UUID voor het spel (een 
\emph on
sessie
\emph default
 in algemene termen) en start een 
\family typewriter
MessageProcessor
\family default
 object met de ontvangen 
\family typewriter
OneToManyService
\family default
, de gegenereerde game UUID als session UUID en de player UUID als sender
 UUID.
\end_layout

\begin_layout Standard
Verder abstraheert deze klasse het verzenden en ontvangen van berichten
 via de global state en het verzenden en ontvangen van de speciale service
 berichten.
 Dit verloopt niet via de 
\family typewriter
MessageProcessor
\family default
 maar rechtstreeks via de 
\family typewriter
OneToManyService
\family default
.
\end_layout

\begin_layout Standard
Ten slotte voorziet deze klasse gedistribueerde mutex functionaliteit (een
 rechtoe-rechtaan implementatie van het Ricart-Agrawala 
\begin_inset CommandInset citation
LatexCommand cite
key "Ricart-Agrawala"

\end_inset

 algoritme was mogelijk dankzij het gebruik van vectorklokken), UUIDs om
 iedere 
\family typewriter
Player
\family default
 te identificeren en de onderliggende netwerklagen die de complexiteit van
 het netwerk abstraheren.
\end_layout

\begin_layout Standard

\family typewriter
Game
\family default
 heeft ook weer een eigen thread (
\family typewriter
Game-Thread
\family default
), wat nodig is omdat 
\family typewriter
Game
\family default
 ontworpen is om gesubclassed te worden en het spel in goede banen te leiden.
 Zie 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:ManyInARowGame.py"

\end_inset

.
\end_layout

\begin_layout Subsection
GlobalState met VectorClock versus Elections
\begin_inset CommandInset label
LatexCommand label
name "sub:GlobalState-vs-Elections"

\end_inset


\end_layout

\begin_layout Standard
We hadden eerst een volledig werkende implementatie met GlobalState en VectorClo
ck, omdat we begrepen hadden uit de les dat dit zou moeten werken.
 Echter, dit bleek niet het geval, omwille van volgende reden: bij vectorklokken
 kunnen we weten wanneer een event zich voor een andere event heeft voorgedaan,
 aangezien de klok van het event dat zich eerst voordeed lager was.
 Er doet zich echter een probleem voor als 2 of meer events zich tegelijk
 voordoen.
 Door gebruik te maken van vectorklokken is het dan niet meer mogelijk te
 achterhalen welk event zich eerst voordeed, en dus is het ook niet mogelijk
 om te weten welke speler eerst een mutex aanvroeg.
 Het is hierbij dan ook niet mogelijk te weten welke klok de 'juiste' klok
 is.
 Een voorbeeld hiervan wordt gegeven in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:VectorClock.py"

\end_inset

.
\end_layout

\begin_layout Standard
Dit hebben we echter pas laat gemerkt en bijgevolg was het verslag al geschreven
 over deze twee modules.
 In deze sectie volgt dan ook de volledige uitleg over de oude aanpak, maar
 dan nu geannotteerd met opmerkingen waarom dit niet werkte.
 
\end_layout

\begin_layout Subsubsection
Schema
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/DistributedGame-GlobalState.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Structuur ten tijde van GlobalState.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
VectorClock.py
\begin_inset CommandInset label
LatexCommand label
name "sub:VectorClock.py"

\end_inset


\end_layout

\begin_layout Standard
Dit is een eenvoudige klasse die een vector clock implementeert, samen met
 een hoop nuttige methods: 
\begin_inset Formula $<$
\end_inset

, 
\begin_inset Formula $\leq$
\end_inset

, 
\begin_inset Formula $=$
\end_inset

, 
\begin_inset Formula $\neq$
\end_inset

, 
\begin_inset Formula $\geq$
\end_inset

, 
\begin_inset Formula $>$
\end_inset

 en 
\family typewriter
isConcurrentWith(other)
\family default
.
 Dit zijn de standaard operaties (zie ook 
\begin_inset CommandInset citation
LatexCommand cite
key "lamport vs vector"

\end_inset

).
 Daarnaast hebben we ook enkele minder voor de hand liggende operaties geïmpleme
nteerd.
\end_layout

\begin_layout Standard
De eerste, 
\family typewriter
isImmediatelyFollowedBy(other)
\family default
, returnet 
\family typewriter
True
\family default
 als en slechts als de vector clock 
\family typewriter
other
\family default
 een enkele component is waarvan de waarde precies één meer is en de overige
 componenten gelijk zijn.
 Een geldig voorbeeld is dan:
\begin_inset Formula \begin{eqnarray*}
clock(A) & = & \{A:1,B:3,C:0\}\\
clock(C) & = & \{A:1,B:3,C:1\}\\
clock(A) & isImmediatelyFollowedBy & clock(C)\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
en een ongeldig voorbeeld:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
clock(A) & = & \{A:1,B:3,C:0\}\\
clock(C) & = & \{A:1,B:3,C:x\}\\
clock(A) & isImmediatelyFollowedBy & clock(C)\\
 & met\, x\,\neq1\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
De tweede, 
\family typewriter
isImmediatelyConcurrentWith(other)
\family default
, returnet 
\family typewriter
True
\family default
 als en slechts als de vector clock 
\family typewriter
other
\family default
 een enkele component is waarvan de waarde precies één meer is, een enkele
 component waarvan de waarde precies één minder is en de de overige componenten
 gelijk zijn.
 Een geldig voorbeeld is dan:
\begin_inset Formula \begin{eqnarray*}
clock(A) & = & \{A:1,B:3,C:0\}\\
clock(C) & = & \{A:0,B:3,C:1\}\\
clock(A) & isImmediatelyConcurrentWith & clock(C)\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
en twee ongeldige voorbeelden:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
clock(A) & = & \{A:1,B:3,C:0,D:2\}\\
clock(C) & = & \{A:0,B:3,C:1,D:5\}\\
clock(A) & isImmediatelyConcurrentWith & clock(C)\end{eqnarray*}

\end_inset


\begin_inset Formula \begin{eqnarray*}
clock(A) & = & \{A:1,B:3,C:0,D:2\}\\
clock(C) & = & \{A:0,B:3,C:x,D:2\}\\
clock(A) & isImmediatelyConcurrentWith & clock(C)\\
 & met\, x\,\neq1\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Een uitgebreide verzameling unit tests zorgt ervoor dat 
\family typewriter
VectorClock
\family default
 zeker goed werkt.
\end_layout

\begin_layout Subsubsection*
Probleem
\end_layout

\begin_layout Standard
Een probleem doet zich echt voor als bijvoorbeeld 3 spelers tegelijk een
 zet doen.
 De 3 spelers vragen dan gelijktijdig een mutex aan (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:GlobalState.py"

\end_inset

).
 De klokken zijn allemaal geinitaliseerd op 0.
 Het volgende doet zich dan voor:
\end_layout

\begin_layout Enumerate
A stuurt mutex bericht met klok: 
\begin_inset Formula ${A:1,B:0,C:0}$
\end_inset


\end_layout

\begin_layout Enumerate
B stuurt mutex bericht met klok: 
\begin_inset Formula ${A:0,B:1,C:0}$
\end_inset


\end_layout

\begin_layout Enumerate
C stuurt mutex bericht met klok: 
\begin_inset Formula ${A:0,B:0,C:1}$
\end_inset


\end_layout

\begin_layout Standard
Bij A komt het bericht van B binnen met klok: 
\begin_inset Formula ${A:0,B:1,C:0}$
\end_inset

, dit is immediately concurrent met de klok van A, dus de klok van A wordt
 geset op 
\begin_inset Formula ${A:1,B:1,C:0}$
\end_inset


\end_layout

\begin_layout Standard
Daarn komt bij A komt het bericht van C binnen met klok: 
\begin_inset Formula ${A:0,B:0,C:1}$
\end_inset

, deze valt niet te mergen met de klok van A, dus weten we niet welke speler
 als eerst de mutex krijgt.
 De andere spelers hebben hetzelfde probleem.
\end_layout

\begin_layout Subsubsection
GlobalState.py
\begin_inset CommandInset label
LatexCommand label
name "sub:GlobalState.py"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
GlobalState
\family default
 zorgt ervoor dat berichten in de correcte volgorde worden gezet voordat
 ze doorgegeven worden aan de hoger liggende laag.
 Hierbij wordt gebruik gemaakt van vector klokken.
 We gebruiken
\begin_inset Note Note
status open

\begin_layout Plain Layout
gebruiken we die nog steeds? of is dit nog van het vorig verslag en moet
 dit 
\begin_inset Quotes eld
\end_inset

gebruikten
\begin_inset Quotes erd
\end_inset

 zijn?
\end_layout

\end_inset

 vector klokken en niet Lamport klokken o.w.v.:
\end_layout

\begin_layout Quotation
Mattern and Fidge developed vector clocks to overcome the shortcoming of
 Lamport's clocks: the fact that from 
\begin_inset Formula $L(e)<L(e')$
\end_inset

 we cannot conclude that 
\begin_inset Formula $e\rightarrow e'$
\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "lamport vs vector"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
GlobalState
\family default
 verwacht een 
\family typewriter
OneToManyService
\family default
 instantie, een session UUID en een sender UUID.
 De session UUID dient als destination (als 
\begin_inset Quotes eld
\end_inset

kanaal
\begin_inset Quotes erd
\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
kanaal weer niet zo duidelijk, ligt wss aan mij...
\end_layout

\end_inset

 eigenlijk) voor 
\family typewriter
OneToManyService
\family default
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:OneToManyService"

\end_inset

.
 In het chatroom voorbeeld komen zo alle berichten voor die chatroom bij
 alle andere deelnemers aan.
 De sender UUID dient om iedere deelnemer uniek te kunnen identificeren.
\end_layout

\begin_layout Standard
Even vooruitblikkend op vier op een rij: het is een vereiste dat de volgorde
 van zetten overal hetzelfde is.
 Dat zal geregeld worden d.m.v.
 een gedistribueerde mutex in 
\family typewriter
Game.py
\family default
 (zie 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Game.py"

\end_inset

).
 Als extra eigenschap stellen we nog dat voor niet-mutual exclusion berichten
 moet gelden dat indien ze gelijk gestuurd worden, de volgorde niet uitmaakt.
 Bijvoorbeeld in het geval van chatberichten maakt de volgorde uit waarin
 iemand iets zegt en wanneer mensen afwisselend iets zeggen, maar als ze
 op hetzelfde tijdstip iets zeggen, maakt de volgorde niet uit.
 Vandaar de 
\begin_inset Quotes eld
\end_inset

extra operaties
\begin_inset Quotes erd
\end_inset

 in 
\family typewriter
VectorClock.py
\family default
 (zie 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:VectorClock.py"

\end_inset

): 
\family typewriter
isImmediatelyFollowedBy(other)
\family default
 en 
\family typewriter
isImmediatelyConcurrentWith(other)
\family default
.
 Gebruik maken van deze operaties zorgt ervoor dat steeds gewacht wordt
 op ontbrekende berichten!
\end_layout

\begin_layout Standard
Ook 
\family typewriter
GlobalState
\family default
 module heeft zijn eigen thread (
\family typewriter
GlobalState-Thread
\family default
).
 Dat is nodig om berichten te herordenen indien ze niet in de juiste volgorde
 aan zijn gekomen.
\begin_inset Newline newline
\end_inset

Berichten die door de 
\family typewriter
OneToManyService
\family default
 ontvangen werden met onze session UUID als bestemming, worden opgehaald
 en in een wachtkamer geplaatst.
 Nadat alle binnekomende berichten opgehaald zijn, worden de berichten in
 de wachtkamer volgens hun vectorklok gesorteerd.
 Diegene met de laagste klokwaarde wordt eruit gepikt.
 Indien de huidige klokwaarde van de 
\family typewriter
GlobalState
\family default
 (zijn 
\emph on
frontier
\emph default
) 
\begin_inset Quotes eld
\end_inset

immediately followed
\begin_inset Quotes erd
\end_inset

 of 
\begin_inset Quotes eld
\end_inset

immediately concurrent
\begin_inset Quotes erd
\end_inset

 is door deze laagste klokwaarde, dan mag dit bericht ontvangen worden en
 wordt het uit de wachtkamer gehaald.
 Vervolgens wordt de eerstvolgende laagste klokwaarde eruit gepikt, enzovoort,
 totdat er geen bericht meer kan ontvangen worden.
\end_layout

\begin_layout Standard
Alle verzonden en ontvangen berichten worden opgeslagen in een SQLite database,
 in een tabel 
\family typewriter
MessageHistory
\family default
, niet zozeer voor persistentie, maar vooral o.w.v.
 overbodig geheugengebruik: het is niet nodig om alle berichten in het geheugen
 te houden.
 Indien er dan achteraf een nieuw proces wil joinen, kan de global state
 in blokken van berichten die uit deze database worden gehaald, worden doorgestu
urd (via de speciale 
\emph on
service-to-service
\emph default
 bestemming van 
\family typewriter
OneToManyService
\family default
) en zo ook de gehele global state reconstrueren.
\end_layout

\begin_layout Standard
Ook voor GlobalState zijn er uitgebreide unit tests en ook daarvan zijn
 we dus zeker dat het goed werkt.
 Bovendien worden hierbij 
\family typewriter
VectorClock
\family default
 en 
\family typewriter
Service
\family default
 gebruikt, dus indien deze tests succesvol blijken, hebben we ook die nogmaals
 getest.
\begin_inset Note Note
status open

\begin_layout Plain Layout
?
\end_layout

\end_inset


\end_layout

\begin_layout Section
Many In A Row
\begin_inset CommandInset label
LatexCommand label
name "sec:Many-In-A"

\end_inset


\end_layout

\begin_layout Subsection
ManyInARowService.py
\begin_inset CommandInset label
LatexCommand label
name "sub:ManyInARowService.py"

\end_inset


\end_layout

\begin_layout Standard
Hierin bevindt zich de 
\family typewriter
ManyInARowService
\family default
 class, wat een subclass is van 
\family typewriter
OneToManyService
\family default
.
 Het bevat enkele vaste instellingen, zoals het zeroconf service type (
\family typewriter
_Many_In_A_Row._tcp
\family default
) en multicast poort nummer.
 Het voorziet een hele hoop callbacks die betrekking hebben op de GUI, zodat
 de GUI peers, players en actieve games kan tonen.
\end_layout

\begin_layout Standard
Aan de hand van de callbacks die het ontvangt van 
\family typewriter
ZeroconfMessaging
\family default
 (via 
\family typewriter
OneToManyService
\family default
), is het in staat om bij iedere netwerk-wijde verandering zijn eigen service
 description te updaten en zo de huidige netwerk-wijde toestand verder te
 propageren.
 Het houdt een lijst bij van actieve spellen en welke spelers erin meespelen
 en speelt deze informatie door naar de GUI via callbacks.
 
\end_layout

\begin_layout Standard
Er zijn ook 3 methods voorzien die vanuit 
\family typewriter
ManyInARowGame
\family default
 dienen aangeroepen te worden opdat de netwerk-wijde toestand up-to-date
 blijft: 
\family typewriter
hostGame()
\family default
, 
\family typewriter
joinGame()
\family default
 en 
\family typewriter
leaveGame()
\family default
.
 Deze dienen om respectievelijk een spel dat gehost is toe te voegen aan
 de lijst van gebroadcaste spellen, of om een speler toe te voegen of te
 verwijderen aan een gebroadcast spel.
\end_layout

\begin_layout Subsection
ManyInARowGame.py
\begin_inset CommandInset label
LatexCommand label
name "sub:ManyInARowGame.py"

\end_inset


\end_layout

\begin_layout Standard
Nu zijn we helemaal bovenaan in de hiërarchie: hierin zit alle spellogica.
 Al het voorgaande is puur ter ondersteuning: om deze code eenvoudig te
 maken.
\end_layout

\begin_layout Standard

\family typewriter
ManyInARowGame 
\family default
is een afgeleide klasse van Game en bevat een 
\family typewriter
MessageProcessor 
\family default
die berichten over het spel hiernaar doorgeeft.
 Ook worden spelberichten via de 
\family typewriter
MessageProcessor
\family default
 doorgestuurd.
 Deze berichten hebben elk een bepaald type, dat representatief is voor
 een bepaalde functionaliteit in het spel.
 
\end_layout

\begin_layout Standard
Het spelbord wordt in deze klasse bijgehouden, en aangepast indien een andere
 speler een zet doet.
 Als een bericht over het spel binnenkomt, wordt dat hier verwerkt en naar
 de GUI doorgeven.
 De GUI roept functies in deze klasse aan om acties van de speler aan te
 geven zoals bvb een zet doen of een chatbericht verzenden.
\end_layout

\begin_layout Section
Extra's
\end_layout

\begin_layout Standard
Om de standaardimplementatie wat meer uit te breiden hebben we volgende
 extra's geïmplementeerd:
\end_layout

\begin_layout Itemize
Gebruik van Zeroconf voor het ontdekken van andere spelers en spellen op
 het netwerk
\end_layout

\begin_layout Itemize
Meerdere spellen tegelijk spelen in 1 applicatie
\end_layout

\begin_layout Itemize
Gebruiker kan informatie over een spel opvragen door met de muis over het
 spel te bewegen in de 
\begin_inset Quotes eld
\end_inset

actieve spellen
\begin_inset Quotes erd
\end_inset

 lijst
\end_layout

\begin_layout Itemize
Mogelijkheid om te chatten
\end_layout

\begin_layout Itemize
Speler ziet waar zijn blokje zal vallen door over de kolommen te bewegen
 met de muis
\end_layout

\begin_layout Itemize
Mogelijkheid om een AI-speler te laten spelen
\begin_inset Note Note
status open

\begin_layout Plain Layout
sorry Kristof
\end_layout

\end_inset


\end_layout

\begin_layout Section
Gebruik 
\begin_inset Note Note
status open

\begin_layout Plain Layout
kan iemand dit nog snel nalezen? heb ik alles?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Bij het starten van het programma wordt gevraagd een naam op te geven.
 Dit is verplicht om verder te mogen gaan.
\end_layout

\begin_layout Standard
Na het ingeven van de naam wordt het hoofdvenster getoond.
 Hierin worden lijsten getoond met actieve spellen, actieve peers en actieve
 spelers op het netwerk.
 Er kan informatie over deze 3 opgevraagd worden door er met de muis over
 te bewegen.
 Bij een spel wordt er dan informatie getoond over het aantal rijen en kolommen
 dat in dat spel gebruikt wordt, wanneer het spel gestart werd, hoelang
 men moet wachten tussen verschillende zetten enzovoort.
\end_layout

\begin_layout Standard
Een nieuw spel starten kan door op de 
\begin_inset Quotes eld
\end_inset

add
\begin_inset Quotes erd
\end_inset

 knop in het hoofdvenster te klikken.
 Er wordt dan een venster getoond met opties voor het spel.
 Er kan een naam opgegeven worden, wat commentaar en informatie over het
 aantal rijen, kolommen en het aantal milliseconden tussen 2 zetten.
 Na het starten van dat spel wordt dit zichtbaar voor alle andere spelers
 op het netwerk.
 Zij kunnen dan joinen door te dubbelklikken op het spel in de lijst.
 Vanaf het moment dat er 2 spelers in een spel zitten kan er gespeeld worden.
 Meerdere spellen joinen kan door te dubbelklikken op meerdere spellen in
 de lijst.
 Ieder spel wordt dan in een apart tabblad geopend.
\end_layout

\begin_layout Standard
Een spel freezen, om de consistentie te controleren, kan eenvoudig door
 op de freeze-knop te drukken.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
klote latex zet dit op een aparte pagina :P
\end_layout

\end_inset

Als laatste is het ook nog mogelijk om een AI-speler te laten spelen.
 Hiervoor moet de checkbox rechtsboven in het venster worden aangevinkt.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "TCP/IP model"

\end_inset


\emph on
TCP/IP model
\emph default
, Wikipedia, 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://en.wikipedia.org/wiki/TCP/IP_model
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "zeroconf networking"

\end_inset


\emph on
Zero configuration networking
\emph default
, Wikipedia, 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://en.wikipedia.org/wiki/Zero_configuration_networking
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "RFC3927"

\end_inset


\emph on
RFC 3927: Dynamic Configuration of IPv4 Link-Local Addresses
\emph default
, S.
 Cheshire (Apple Computer); B.
 Aboboa (Microsoft Corporation); E.Guttman (Sun Microsystems), May 2005,
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://tools.ietf.org/html/rfc3927
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "pybonjour"

\end_inset


\emph on
pybonjour: Pure-Python interface to Apple Bonjour and compatible DNS-SD
 libraries
\emph default
, 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://code.google.com/p/pybonjour/
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Apple Bonjour"

\end_inset


\emph on
Bonjour
\emph default
, Apple, 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://apple.com/bonjour
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Avahi"

\end_inset


\emph on
Avahi
\emph default
, 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://avahi.org/
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "IP multicast"

\end_inset


\emph on
IP multicast
\emph default
, Wikipedia, 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://en.wikipedia.org/wiki/IP_multicast
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "lamport vs vector"

\end_inset


\emph on
 Distributed Systems: Concepts and Design (fourth edition) — chapter 11:
 Time and Global States (page 447)
\emph default
, George Coulouris; Jean Dollimore; Tim Kindberg, Addison Wesley (2005)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Ricart-Agrawala"

\end_inset

Ricart-Agrawala algorithm, Wikipedia, 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://en.wikipedia.org/wiki/Ricart-Agrawala_algorithm
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "DNS gebruikt UDP"

\end_inset

Ricart-Agrawala algorithm, Wikipedia, 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://en.wikipedia.org/wiki/Domain_Name_System#Protocol_details
\end_layout

\end_inset


\end_layout

\end_body
\end_document
